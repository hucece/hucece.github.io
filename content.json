[{"title":"react笔记001","date":"2017-05-28T12:13:18.000Z","path":"2017/05/28/react001/","text":"导语 在前两个月因为一个偶然的原因，接触到了react,虽然用react+redux速成一个小作品，但是总是心里不得劲，没有好好地去学习和研究react。所以趁着这两天项目不是很忙，就开始着手重新学习react。react001是来记录如何搭建react环境。 初识react react是一个构建用户界面的javascript库，React 使用 JSX 来替代常规的 JavaScript。 JSX是js语言的一种拓展，长得像HTML,但不是HTML,在w3c上我们可以看到对jsx的介绍[http://www.runoob.com/react/react-jsx.html]。初次写react的demo时，我内心是惊呆了的，在之前我实习时，使用了angular.js的这种MVC框架，给我的感觉是他添加了一些后台的概念，整个项目是模块化，编写代码我们平时的习惯还能比较相近；然而，react却是换一个新的概念V存在，项目是组件化的，一切皆组件，语法、编写习惯和平时接触的有些截然不同的感觉，这也就更加增长了我的好奇心。React是将一个项目拆分成大大小小的组件，大组件套小组件，每一个组件可以有自己的文件，可以根据我们的输入而输出相应内容，有一种函数式编程的感觉。。。好了，不说了，太磨叽了，到下一个话题吧。 环境搭建create-react-app由于React需要用到JSX语法，甚至有人会使用ES6语法（比如我），每一组件嵌套时，需要引入单个文件里的组件等等等。。。需要有一个环境可以转换JSX，翻译ES6,这样浏览器来能听得懂我们在讲什么。我推荐使用官方出品的create-react-app,简单，快捷。 全局安装create-react-app 1npm install -g create-react-app 创建一个react项目 1create-react-app &quot;react001&quot; 进入项目，开启项目 12cd react001npm start 在localhost:3000中可以看到我们的界面，create-react-app使用了热加载，所以当我们的项目文件发生改变时，可以实时刷新我们的界面，如果有错误，也会在界面中显示，是不是很方便呢。 webpack手动搭建 全局安装webpack 1npm install -g webpack 创建项目 123mkdir demo //创建文件夹democd demo //进入demo文件夹npm init //步骤填写最终生成package.json文件，也可以直接entry，这个文件描述了项目的基本信息和项目依赖的第三方插件的信息 安装插件 npm install 时有–save-dev和–save，两者将安装的插件分别记录在package.json的dependencies和devDependencies中。–save-dev: 项目开发中依赖的插件，比如webpack（用来打包项目），babel（ES6代码转为ES5代码）,在项目打包上线之后，这些插件就用不上了.–save: 项目在运行时依赖的插件，比如react,jquery,react-dom. 1npm install webpack webpack-dev-server --save-dev webpack-dev-server是一个小型的Node.js Express服务器。参考详解webpack-dev-server的使用 添加并且配置webpack.confing.js项目目录：12345------app +index.html +index.js------package.json------webpack.config.js webpack.config.js配置123456789101112131415161718var path = require(&apos;path&apos;);var webpack = require(&apos;webpack&apos;);module.exports = &#123; entry: path.resolve(__dirname,&apos;app/index.js&apos;), output: &#123; path: __dirname+&quot;/build&quot;, filename: &apos;./js/bundle.js&apos; &#125;, resolve: &#123; extensions: [&apos;.js&apos;,&apos;.jsx&apos;] &#125;, devServer: &#123; historyApiFallback: true, //不跳转，在单页面开发时非常有用，依赖于HTML5 history API inline: true, //实时刷新 hot: true //使用热加载插件HotModuleReplacementPlugin &#125;&#125; 自动打开和热加载1npm install open-browser-webpack-plugin --save-dev 在module.exports对象中添加属性plugin数组：123456789var OpenBrowserPlugin = require(&quot;OpenBrowserPlugin&quot;);plugins: [ //热加载插件 new webpack.HotModuleReplacementPlugin(), //打开浏览器 new OpenBrowserPlugin(&#123; url: &apos;http://localhost:8080&apos; &#125;)], HotModuleReplacementPlugin:是用来做热替换的，每次开发环境下的资源发生变更之后都会自动重新打包输出，不需要重新构建.OpenBrowserPlugin:构建完成之后自动打开浏览器的”localhost:8080”这个路径 html模板插件如果我们创建了index.html，还需要手动把生成的bundle.js添加到script标签中，如果说还有别的输出，比如后面可能为了性能问题而使用vendor提取打包公共模块也需要手动添加，所以可以使用html模板插件，可自动将output中的文件引入到html页面 12345678910npm install HtmlWebpackPlugin --save-devwebpack.config.jsvar OpenBrowserPlugin = require(&quot;htmlWebpackPlugin&quot;);plugins: [ //html魔板插件 new htmlWebpackPlugin(&#123; template: __dirname+&apos;/app/index.html&apos; &#125;)] 修改package.json文件的scripts 1234&quot;scripts&quot;: &#123;//命令行输入npm start，相当于输入npm webpack-dev-server --progress --colors,打开webpack-dev-server服务器 &quot;start&quot;: &quot;webpack-dev-server --progress --colors&quot;&#125;, 命令行输入npm start,浏览器自动打开localhost:8080,修改index.js保存后，webpack自动编译打包，页面自动刷新。 目前，运行环境已经搭建好了，只是还差babel，react,react-dom等等的插件。这个留着下一节再讲。","tags":[]},{"title":"this解释","date":"2017-05-28T02:30:58.000Z","path":"2017/05/28/third/","text":"导语： 这两周在空闲之余鼓捣react，使用的是es6，其中有用到箭头函数，平时一向爱使用this的我发现这个箭头函数里的this和普通使用的this有所不同，故今天趁着放假，对this总结一下。 什么是thisthis是当前执行函数的上下文。曾读《javascript语言精粹》中介绍了this，其中总结了了平时我们在代码中this在不同的场景中使用,表现出不同的期望，这对于我在平时的工作中受益匪浅。 函数调用 (alert(“hello world”)) 方法调用 (console.log(“hello world”)) 构造函数调用 (new Object()) 隐式调用 (alert.apply(null,”hello world”))函数调用 this: 全局对象(window/global) 全局对象是由执行的环境决定的。在浏览器里它是window对象。在严格模式下，为undefined.12345678910111213141516var a = &quot;hello world&quot;;function fnUnStrict()&#123; console.log(this === window); //true&#125;function fnStrict()&#123; &apos;use strict&apos; console.log(this === undefined) //true&#125;var parms = &#123; text: &apos;hello world&apos;, greet: function()&#123; function say()&#123; console.log(this === window); //true &#125; &#125;&#125; 方法调用 拥有这个方法的对象。 一个方法是一个函数，作为属性存在于对象中。1234567var parms = &#123; name: &apos;xiaoming&apos;, age: &apos;3&apos;, go: function()&#123; console.log(this === parms); //true &#125;&#125; 构造函数调用 新构造出来的新对象 new后跟着一个构造函数，产生新的对象12345678var DrawMap = function(container)&#123; this.map = new google.maps.Map(document.getElementById(container), &#123; center: &#123;lat: 39.916527, lng: 116.397128&#125;, zoom: 8 &#125;); console.log(this); &#125; var myMap = new DrawMap(&quot;map&quot;); //打印出来的this指的是myMap 隐式调用 在隐式调用.call()或.apply()中，this是第一个参数。 当函数被.call()或者.apply()调用时，执行的是隐式调用方法.call(thisArg[, arg1[, arg2[, …]]])将接受的第一个参数thisArg作为调用时的上下文，arg1, arg2, …这些则作为参数传入被调用的函数。方法.apply(thisArg, [args])将接受的第一个参数thisArg作为调用时的上下文，并且接受另一个类似数组的对象[args]作为被调用函数的参数传入。 var Student = function(name){ this.name = name; console.log(this.name) //&apos;hehe&apos; console.log(this); //school } var School = function(name){ Student.call(this,name); } var school = new School(&apos;hehe&apos;); 绑定函数 this是.bind()的第一个参数 绑定函数是一个与对象绑定的函数。通常它是通过在原函数上使用 .bind()来创建的。原函数和绑定的函数共享代码跟作用域，但是在执行时有不同的上下文。方法.bind(thisArg[, arg1[, arg2[, …]]])接受第一个参数thisArg作为绑定函数执行时的上下文，并且它接受一组可选的参数 arg1, arg2, …作为被调用函数的参数。它返回一个绑定了thisArg的新函数。 var sum = function(num){ console.log(this*num); //6 } var three = sum.bind(3); three(2); 箭头函数 this是箭头函数定义时封装好的上下文 function Fn(name,age){ this.name = name; this.age = age; } Fn.prototype.study = function(){ console.log(this); //student; } Fn.protorype.like = ()=&gt;{ console.log(this); //window; } var student = new Fn(&quot;xiaoming&quot;,&quot;6&quot;); student.study(); student.like(); 箭头函数中的this总是绑定的是此法作用域，即使修改上下文(apply,call,bind),this也不会被改变。 var nums = [2,5,7]; (function(){ var fn = ()=&gt;{ console.log(this) //[2,5,7] } fn.call([5]); //[2,5,7] fn.apply([23]); //[2,5,7] var fu = fn.bind([0]); fu() }).call(nums); 结论 在我们使用this时，注意两点：如果在普通的我们使用的情况下，需要看函数是如何被调用的，这样确定this,上面所阐述的几个例子可以作为参考。在es6中，确定this，需要看这个函数被定义是的环境 。","tags":[]},{"title":"简单的原生拖拽","date":"2017-04-18T13:09:57.000Z","path":"2017/04/18/second/","text":"忙碌的一个周过去了，拖到今天才把这篇拖拽的文章写出来。 说道前端的拖拽，我们想到了jqueryUi拖拽功能，用起来还不错，最近我们有一个功能中需要用到拖拽这个功能，而我又不想用jquery-ui来实现，因为这样，我们就要引入几个jquery-ui的文件。所以，原生手动走起。。。 中间的小黄块在框中拖动。 效果 函数startDrag(入口函数，直接调用)startDrag(container,box):函数； container: DOM元素，表示要拖动的区域； box: DOM元素，表示要拖动的盒子。Ps:box相当于container是绝对定位的。 在startDrag的parms中定义了5个属性（container,dragBox,move,disX,disY），2个方法(init,getPosition)。 属性：1) container: 存储形参“container”，也就是存储的是一个HTML DOM元素，表示的是盒子在这个区域拖动。2) dragBox: 存储形参“dragBox”，也就是存储的事宜个HTML DOM的元素，表示的是被拖动的盒子。3) move: [Boolean]值，true表示盒子可以随着鼠标拖动，false表示盒子不可以随着鼠标拖动。4) disX: [number],鼠标按下的瞬间，鼠标和这盒子左边框的距离。5) disY: [number],鼠标按下的瞬间，鼠标和这盒子上边框的距离。方法：1) init: 在调用startDrag时，实际运行的是这个函数2) getPosition:参数node为一个HTML DOM元素，获取一个DOM元素距离窗口左边和右边的距离，返回的一个对像。 init: getPosition:获取节点相当于浏览器窗口的位置。 1)offsetLeft:只读，返回当前元素左上角相当于HTML offsetParent节点的左边界偏移的像素值。2)offsetParent: 返回一个指向最近的（指包含级上的最近）包含该元素的定位函数，如果没有定位的元素，则offsetParent为最近的table元素对象或者是根元素（标准为html,怪异模式为body）.","tags":[]},{"title":"jsGrid样式自定义","date":"2017-04-01T07:01:18.000Z","path":"2017/04/01/first/","text":"开始用自己搭建的博客写文章，开森。。。 之所以写这篇博客，并不是我所介绍的内容很新颖独特，而是当我在网上搜寻解决这些问题的办法时，很少搜到给我明确方向的答案，所以，在搜寻答案失败之后，我还是打算自己来解决，一方面，如果有人遇到和我一样的问题而没有搜到答案，还有一方面，给我自己做一个笔记。不喜勿喷哦。。。 在我的项目中，采用了jqGrid这个表格插件，官方demos中的样式表采用的是jquery-ui的样式表来美化这个表格,由于用久了bootstrap，比较喜欢它简洁大方的气质，所以我选择用bootstrap来美化，但是效果不尽人意（样式冲突），所以，需要在调试中找出这些样式，然后，重新定义这些样式来达到我们的效果。 效果 引入的文件： 样式表这个例子中和原来的风格完全不一样。这张图片的每一个不同颜色的框都是一个表格。当然外面被div套着。在我们没有写自定义的样式表时，我们打开谷歌的调试，看样式，根据他的样式class来写自己自定义的样式表。比如：他的样式为.ui_state_hover{ color:#f8f8f8; },我们可以改成.ui_state_hover{color:#999;}这个样式表一定要放在ui.grid.css，bootstrap.css的后面来进行覆盖，如果覆盖不了，我们就进行权重比较。 图标说完了样式表，接下来说说图标。Jqgrid本身是不带图标的，一般是用别的例如jquery-ui来进行图标的替换。Bootstrap中也有图标。这里图标就成了一个问题了。就算是我们看到网页加载完后有图标的class，但是都没有图形，我们需要在表格动态加载完成之后，将图标的class换成bootstrap的图形icon，所以在gridComplete事件中来干这件事情。当然这里的图标的id也是不同的版本jqgrid有可能有所不同，所以还得再谷歌的调试工具中来看。 ###PS关于版本（主要是jqGrid.js，ui.grid.css）： 如果jqGrid.js和ui.grid.css的版本有所变化，那么那个tablestyle.css文件和index.js文件就得重新写，需要重新写的地方就是最后两张图所展示的部分。所以一般确定好这两个文件的版本，不可轻易变换。 后记我的代码可能不是适合你，主要在于思路和方法，自己动手，丰衣足食。","tags":[{"name":"jsGrid bootstrap table","slug":"jsGrid-bootstrap-table","permalink":"http://yoursite.com/tags/jsGrid-bootstrap-table/"}]},{"title":"Hello World","date":"2017-04-01T05:55:13.879Z","path":"2017/04/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]