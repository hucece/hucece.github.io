[{"title":"防抖和节流","date":"2017-07-10T00:57:47.000Z","path":"2017/07/10/fourth/","text":"导语 最近在项目中，websocket每过50毫秒就会给给我推一个数据，我需要做的是将数据映射在一个实时变化的折线图（highChart），而我们对这个折线图的需求不过是想看到大致的速度和高度的变化趋势，所以说不必要每个数据都放在我们highChart的折线图上，只要 每间隔30秒添加数据到折线图，我首先想到了的是使用setTimeout，后来在一个后台同事的提醒下做节流/防抖，于是百度，谷歌，然后研究了一番，最后做出了效果，以下是我的总结。 概念节流： 强调是在一定时间内，调用函数的最大次数，比如在100毫秒内最多调用函数一次保证的是x毫秒恒定的执行次数。防抖： 强调的是事件频繁触发一定时间后才执行，或者第一次触发事件的时候就执行，直到停止触发后等待一段时间才执行。 保证的是把触发非常频繁的时间合并成一次执行。(图片引自User Interfaces | Meteor Guide)（https://guide.meteor.com/ui-ux.html） 在我的项目中数据是不断的进行推送的，直到这个发送数据的那个某某机器掉线，所以最终采用的是节流。在网上有很多关于节流和防抖的一些代码，大部分人用的是loadsh或者underscore的中的debounce、throttle源码，根据源码我们来看下节流和防抖的区别，并且将这个代码运用在我的项目中。 防抖先来一个我在网上看到并且进行改造的简化版的防抖。 &lt;div id=&quot;container&quot; style=&quot;width:120px;height:120px;border: 1px solid #ccc;&quot;&gt;&lt;/div&gt; &lt;script&gt; window.onload = function(){ /* *@parm func ： {function} ，需要触发执行的回调函数 *@parm delay: {num} ,时间间隔，单位为毫秒 */ function debouce(func,delay){ //定时器 var timer = null; return function(){ var context = this; //执行上下文环境，因为在setTimeout中的回调函数中this = window var args = arguments; //参数 clearTimeout(timer); //清除上次定义的定时器 timer = setTimeout(function(){ //重现赋值定时器 func.apply(context,args); //执行需要出发的函数 },delay) } } function consoleSomething(){ console.log(&quot;防抖防抖&quot;) } document.getElementById(&quot;container&quot;).onmousemove = debouce(consoleSomething,3000); } &lt;/script&gt; 节流函数debouce产生了一个闭包（最后return），我们知道闭包可以使得函数有权访问另一个函数作用域内变量，这个定义的timer可以被返回的函数func不断访问，而且不存在于全局中，防止全局污染。每次我们把鼠标放在container区域不出来就会触发onmousemove的回调函数func，func把之前的定时器清除掉，然后重新对定时器进行赋值，这样下去，除非我们把鼠标移出，最后一个定时器不会被清除，在delay后执行consoleSomething这个回调函数。从这个简化版的例子中，我们应该对防抖的概念有比较清晰的印象了。 &lt;button id=&quot;button&quot;&gt;click me&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; //获取时间戳 var _now = Date.now || function(){ return new Date().getTime(); } /* *@params func:{function},触发执行的回调函数 *@params wait:{num} ,时间间隔，单位为毫秒 *@params immediate:{boolea},true表示在停止触发后的一段时间间隔后执行回调，false:表示第一次触发就执行 */ var debouce = function(func,wait,immediate){ //定时器，传入的参数，执行上下文环境，触发回调函数的时间戳 var timeout,args,context,timestamp,result; var later = function(){ var last = _now() - timestamp; //打算执行回调函数是间戳-触发回调函数的时间戳 if(last&lt;wait &amp;&amp; last&gt;0){ //时间差小于时间间隔，并且时间差大于0 timeout = setTimeout(later,wait-last); //timeout重新复制，并不执行回调函数 }else{ timeout = null; if(!immediate){ //如果不是立即执行 result = func.apply(context,args); //执行回调函数 if(!timeout){ context = args = null; } } } } return function(){ context = this; //上下文执行环境 args = arguments; //传入的参数 timestamp = _now(); //触发回调的时间戳 //传入的参数immediate为true,并且定时器为空,callNow为true,立即执行 var callNow = immediate &amp;&amp; !timeout; //timeout没有赋值定时器，赋值定时器 if(!timeout){ timeout = setTimeout(later,wait); } //如果立即执行 if(callNow){ result = func.apply(context,args); //触发后立即执行回调函数 context = args = null; } } } var consoleSomething = function(){ console.log(&quot;防抖防抖防抖&quot;); } window.onload = function(){ document.getElementById(&quot;button&quot;).onclick = debouce(consoleSomething,1000,true); } &lt;/script&gt; 同样也是使用的闭包机制，而不同的是还可以选择是否事件频繁触发一定时间后才执行，或者第一次触发事件的时候就执行，直到停止触发后等待一段时间才执行。其中，这个核心点在于： 定时器（timeout)是否为空，如果为空，就重新赋值定时器，如果不为空，则不再赋值定时器，这样避免频繁触发频繁添加不必要的定时器（timeout）。 触发时刻的时间戳(timestamp)在不断改变，规定的时间间隔(wait)固定的，只要到了定时器该执行(_now)的时候，如果说该执行时刻的时间戳(_now)和最近触发时刻的时间戳(timestamp)的间隔小于规定的额时间间隔(wait)或者小于0，那么说明在规定的时间间隔(wait)内还在不停的触发，所以，更新定时器(timeout)，时间间隔为这这两者的差值(timestamp-_now) 在立即执行回调函数这一块，如果定时器为空，并且是立即执行的指令，则立即执行回调函数，但是，还是要给timeout赋值定时器，但是这并不意味着这个定时器就会执行这个函数，因为他会判断是否是立即执行状态，如果是就不会执行这个函数。而且这个定时器存在的意义如第一条所说。 节流先来一个我在网上看到并且进行改造的简化版的节流。 &lt;div id=&quot;throttle&quot; style=&quot;width: 290px;height:300px;border: 1px solid #ccc;&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* *@param: func:{function},触发执行的回调函数 *@param: delay:{num},执行的时间间隔 */ var throttle = function (func,delay) { var isRun = true; //控制是否添加回调函数， return function(){ if(!isRun) return false; //isRun为false,表示不能添加新的回调函数 isRun = false; var args = arguments; var context = this setTimeout(function(){ func.apply(context,args); isRun = true; //在这个回调函数执行后，isRun为true，才能添加新的回调函数 },delay) } } var consoleSomething = function(){ console.log(&quot;节流节流节流&quot;); } document.getElementById(&quot;throttle&quot;).onclick = throttle(consoleSomething,3000) &lt;/script&gt; 这个例子也是采用的闭包机制，核心点在于是否可以添加回调函数，如果说上一个回调函数在时间间隔delay内还没有执行，那么就不能添加回调函数，始终都只有一个回调函数。当时间间隔后执行了回调函数,将isRun设为true,才能添加下一个回调函数，所以在时间间隔内不断触发的是不会产生新的回调函数，除非已经产生的回调函数已经执行了。从这个简化版的例子中，我们应该对节流的概念有比较清晰的印象了。 &lt;button id=&quot;button&quot;&gt;click me&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; var _now = Date.now || function(){ return new Date().getTime(); } /* *@param func : {function} 触发执行的回调函数 *@param wait : {num} 时间间隔 *@param option : {} 如果想忽略开始边界上的调用，传入{leading:false} * 如果想忽略结尾边界上的调用，传入{trailing:false} */ var _throttle = function(func, wait, options) { //执行上下文环境，闭包传入的参数 var context, args, result; var timeout = null; var previous = 0; //上次执行回调函数的时间点 if (!options) options = {}; //延迟执行函数 var later = function() { // 若设定了开始边界不执行选项，上次执行时间始终为0 previous = options.leading === false ? 0 : _now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; }; //leading:false,这第一次调用不执行function //trailing:false,禁止最后那一次延迟的调用 return function() { var now = _now(); //触发动作的时间戳 //首次执行时，如果设定了开始便不执行回调函数，将上次的执行回调函数的时间戳设置为此次触发的时间戳 if (!previous &amp;&amp; options.leading === false) previous = now; //执行回调函数的剩余时间间隔，总的时间间隔-（这次触发的时间戳-上次执行的时间间隔） var remaining = wait - (now - previous); context = this; args = arguments; //执行回调函数剩余的时间间隔小于0，表示上次执行到现在已经超过了规定的时间间隔； //执行回调函数剩余的时间间隔大于规定的时间间隔表示客户端系统时间呗重新调整过 if (remaining &lt;= 0 || remaining &gt; wait) { if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; result = func.apply(context, args); if (!timeout) context = args = null; //如果延迟执行不存在，且没有设定结尾边界不执行选项 } else if (!timeout &amp;&amp; options.trailing !== false) { timeout = setTimeout(later, remaining); } return result; }; }; var consoleSomething = function(){console.log(&quot;节流节流&quot;)} window.onload = function(){ document.getElementById(&quot;button&quot;).onclick = _throttle(consoleSomething,3000,{}) } &lt;/script&gt; 其中，这个核心点在于： 以第一次触发事件执行回调函数的时间戳为几点，然后每隔wait时间执行一次回调函数，不管用户触发了多少次时间，用户停止点击后，每隔一次触发一次后清掉定时器 剩余的时间间隔remaining为规定的时间间隔(wait)减去现在触发的时间戳（now)和上次执行回调函数的时间戳（previous)的差值，剩余的时间间隔（remaining)表明是否到了该执行此次触发的时候，如果到了，则清除之前的定时器，执行现在这个回调函数否则，如果定时器不存在则重新赋值定时器。 定时器（timeout）给埋下了一个时间段，表明这个时间段中，用户的触发时没有用的。","tags":[]},{"title":"react笔记001","date":"2017-05-28T12:13:18.000Z","path":"2017/05/28/react001/","text":"导语 在前两个月因为一个偶然的原因，接触到了react,虽然用react+redux速成一个小作品，但是总是心里不得劲，没有好好地去学习和研究react。所以趁着这两天项目不是很忙，就开始着手重新学习react。react001是来记录如何搭建react环境。 初识react react是一个构建用户界面的javascript库，React 使用 JSX 来替代常规的 JavaScript。 JSX是js语言的一种拓展，长得像HTML,但不是HTML,在w3c上我们可以看到对jsx的介绍[http://www.runoob.com/react/react-jsx.html]。初次写react的demo时，我内心是惊呆了的，在之前我实习时，使用了angular.js的这种MVC框架，给我的感觉是他添加了一些后台的概念，整个项目是模块化，编写代码我们平时的习惯还能比较相近；然而，react却是换一个新的概念V存在，项目是组件化的，一切皆组件，语法、编写习惯和平时接触的有些截然不同的感觉，这也就更加增长了我的好奇心。React是将一个项目拆分成大大小小的组件，大组件套小组件，每一个组件可以有自己的文件，可以根据我们的输入而输出相应内容，有一种函数式编程的感觉。。。好了，不说了，太磨叽了，到下一个话题吧。 环境搭建create-react-app由于React需要用到JSX语法，甚至有人会使用ES6语法（比如我），每一组件嵌套时，需要引入单个文件里的组件等等等。。。需要有一个环境可以转换JSX，翻译ES6,这样浏览器来能听得懂我们在讲什么。我推荐使用官方出品的create-react-app,简单，快捷。 全局安装create-react-app 1npm install -g create-react-app 创建一个react项目 1create-react-app &quot;react001&quot; 进入项目，开启项目 12cd react001npm start 在localhost:3000中可以看到我们的界面，create-react-app使用了热加载，所以当我们的项目文件发生改变时，可以实时刷新我们的界面，如果有错误，也会在界面中显示，是不是很方便呢。 webpack手动搭建 全局安装webpack 1npm install -g webpack 创建项目 123mkdir demo //创建文件夹democd demo //进入demo文件夹npm init //步骤填写最终生成package.json文件，也可以直接entry，这个文件描述了项目的基本信息和项目依赖的第三方插件的信息 安装插件 npm install 时有–save-dev和–save，两者将安装的插件分别记录在package.json的dependencies和devDependencies中。–save-dev: 项目开发中依赖的插件，比如webpack（用来打包项目），babel（ES6代码转为ES5代码）,在项目打包上线之后，这些插件就用不上了.–save: 项目在运行时依赖的插件，比如react,jquery,react-dom. 1npm install webpack webpack-dev-server --save-dev webpack-dev-server是一个小型的Node.js Express服务器。参考详解webpack-dev-server的使用 添加并且配置webpack.confing.js项目目录：12345------app +index.html +index.js------package.json------webpack.config.js webpack.config.js配置123456789101112131415161718var path = require(&apos;path&apos;);var webpack = require(&apos;webpack&apos;);module.exports = &#123; entry: path.resolve(__dirname,&apos;app/index.js&apos;), output: &#123; path: __dirname+&quot;/build&quot;, filename: &apos;./js/bundle.js&apos; &#125;, resolve: &#123; extensions: [&apos;.js&apos;,&apos;.jsx&apos;] &#125;, devServer: &#123; historyApiFallback: true, //不跳转，在单页面开发时非常有用，依赖于HTML5 history API inline: true, //实时刷新 hot: true //使用热加载插件HotModuleReplacementPlugin &#125;&#125; 自动打开和热加载1npm install open-browser-webpack-plugin --save-dev 在module.exports对象中添加属性plugin数组：123456789var OpenBrowserPlugin = require(&quot;OpenBrowserPlugin&quot;);plugins: [ //热加载插件 new webpack.HotModuleReplacementPlugin(), //打开浏览器 new OpenBrowserPlugin(&#123; url: &apos;http://localhost:8080&apos; &#125;)], HotModuleReplacementPlugin:是用来做热替换的，每次开发环境下的资源发生变更之后都会自动重新打包输出，不需要重新构建.OpenBrowserPlugin:构建完成之后自动打开浏览器的”localhost:8080”这个路径 html模板插件如果我们创建了index.html，还需要手动把生成的bundle.js添加到script标签中，如果说还有别的输出，比如后面可能为了性能问题而使用vendor提取打包公共模块也需要手动添加，所以可以使用html模板插件，可自动将output中的文件引入到html页面 12345678910npm install HtmlWebpackPlugin --save-devwebpack.config.jsvar OpenBrowserPlugin = require(&quot;htmlWebpackPlugin&quot;);plugins: [ //html魔板插件 new htmlWebpackPlugin(&#123; template: __dirname+&apos;/app/index.html&apos; &#125;)] 修改package.json文件的scripts 1234&quot;scripts&quot;: &#123;//命令行输入npm start，相当于输入npm webpack-dev-server --progress --colors,打开webpack-dev-server服务器 &quot;start&quot;: &quot;webpack-dev-server --progress --colors&quot;&#125;, 命令行输入npm start,浏览器自动打开localhost:8080,修改index.js保存后，webpack自动编译打包，页面自动刷新。 目前，运行环境已经搭建好了，只是还差babel，react,react-dom等等的插件。这个留着下一节再讲。","tags":[]},{"title":"this解释","date":"2017-05-28T02:30:58.000Z","path":"2017/05/28/third/","text":"导语： 这两周在空闲之余鼓捣react，使用的是es6，其中有用到箭头函数，平时一向爱使用this的我发现这个箭头函数里的this和普通使用的this有所不同，故今天趁着放假，对this总结一下。 什么是thisthis是当前执行函数的上下文。曾读《javascript语言精粹》中介绍了this，其中总结了了平时我们在代码中this在不同的场景中使用,表现出不同的期望，这对于我在平时的工作中受益匪浅。 函数调用 (alert(“hello world”)) 方法调用 (console.log(“hello world”)) 构造函数调用 (new Object()) 隐式调用 (alert.apply(null,”hello world”))函数调用 this: 全局对象(window/global) 全局对象是由执行的环境决定的。在浏览器里它是window对象。在严格模式下，为undefined.12345678910111213141516var a = &quot;hello world&quot;;function fnUnStrict()&#123; console.log(this === window); //true&#125;function fnStrict()&#123; &apos;use strict&apos; console.log(this === undefined) //true&#125;var parms = &#123; text: &apos;hello world&apos;, greet: function()&#123; function say()&#123; console.log(this === window); //true &#125; &#125;&#125; 方法调用 拥有这个方法的对象。 一个方法是一个函数，作为属性存在于对象中。1234567var parms = &#123; name: &apos;xiaoming&apos;, age: &apos;3&apos;, go: function()&#123; console.log(this === parms); //true &#125;&#125; 构造函数调用 新构造出来的新对象 new后跟着一个构造函数，产生新的对象12345678var DrawMap = function(container)&#123; this.map = new google.maps.Map(document.getElementById(container), &#123; center: &#123;lat: 39.916527, lng: 116.397128&#125;, zoom: 8 &#125;); console.log(this); &#125; var myMap = new DrawMap(&quot;map&quot;); //打印出来的this指的是myMap 隐式调用 在隐式调用.call()或.apply()中，this是第一个参数。 当函数被.call()或者.apply()调用时，执行的是隐式调用方法.call(thisArg[, arg1[, arg2[, …]]])将接受的第一个参数thisArg作为调用时的上下文，arg1, arg2, …这些则作为参数传入被调用的函数。方法.apply(thisArg, [args])将接受的第一个参数thisArg作为调用时的上下文，并且接受另一个类似数组的对象[args]作为被调用函数的参数传入。 var Student = function(name){ this.name = name; console.log(this.name) //&apos;hehe&apos; console.log(this); //school } var School = function(name){ Student.call(this,name); } var school = new School(&apos;hehe&apos;); 绑定函数 this是.bind()的第一个参数 绑定函数是一个与对象绑定的函数。通常它是通过在原函数上使用 .bind()来创建的。原函数和绑定的函数共享代码跟作用域，但是在执行时有不同的上下文。方法.bind(thisArg[, arg1[, arg2[, …]]])接受第一个参数thisArg作为绑定函数执行时的上下文，并且它接受一组可选的参数 arg1, arg2, …作为被调用函数的参数。它返回一个绑定了thisArg的新函数。 var sum = function(num){ console.log(this*num); //6 } var three = sum.bind(3); three(2); 箭头函数 this是箭头函数定义时封装好的上下文 function Fn(name,age){ this.name = name; this.age = age; } Fn.prototype.study = function(){ console.log(this); //student; } Fn.protorype.like = ()=&gt;{ console.log(this); //window; } var student = new Fn(&quot;xiaoming&quot;,&quot;6&quot;); student.study(); student.like(); 箭头函数中的this总是绑定的是此法作用域，即使修改上下文(apply,call,bind),this也不会被改变。 var nums = [2,5,7]; (function(){ var fn = ()=&gt;{ console.log(this) //[2,5,7] } fn.call([5]); //[2,5,7] fn.apply([23]); //[2,5,7] var fu = fn.bind([0]); fu() }).call(nums); 结论 在我们使用this时，注意两点：如果在普通的我们使用的情况下，需要看函数是如何被调用的，这样确定this,上面所阐述的几个例子可以作为参考。在es6中，确定this，需要看这个函数被定义是的环境 。","tags":[]},{"title":"简单的原生拖拽","date":"2017-04-18T13:09:57.000Z","path":"2017/04/18/second/","text":"忙碌的一个周过去了，拖到今天才把这篇拖拽的文章写出来。 说道前端的拖拽，我们想到了jqueryUi拖拽功能，用起来还不错，最近我们有一个功能中需要用到拖拽这个功能，而我又不想用jquery-ui来实现，因为这样，我们就要引入几个jquery-ui的文件。所以，原生手动走起。。。 中间的小黄块在框中拖动。 效果 函数startDrag(入口函数，直接调用)startDrag(container,box):函数； container: DOM元素，表示要拖动的区域； box: DOM元素，表示要拖动的盒子。Ps:box相当于container是绝对定位的。 在startDrag的parms中定义了5个属性（container,dragBox,move,disX,disY），2个方法(init,getPosition)。 属性：1) container: 存储形参“container”，也就是存储的是一个HTML DOM元素，表示的是盒子在这个区域拖动。2) dragBox: 存储形参“dragBox”，也就是存储的事宜个HTML DOM的元素，表示的是被拖动的盒子。3) move: [Boolean]值，true表示盒子可以随着鼠标拖动，false表示盒子不可以随着鼠标拖动。4) disX: [number],鼠标按下的瞬间，鼠标和这盒子左边框的距离。5) disY: [number],鼠标按下的瞬间，鼠标和这盒子上边框的距离。方法：1) init: 在调用startDrag时，实际运行的是这个函数2) getPosition:参数node为一个HTML DOM元素，获取一个DOM元素距离窗口左边和右边的距离，返回的一个对像。 init: getPosition:获取节点相当于浏览器窗口的位置。 1)offsetLeft:只读，返回当前元素左上角相当于HTML offsetParent节点的左边界偏移的像素值。2)offsetParent: 返回一个指向最近的（指包含级上的最近）包含该元素的定位函数，如果没有定位的元素，则offsetParent为最近的table元素对象或者是根元素（标准为html,怪异模式为body）.","tags":[]},{"title":"jsGrid样式自定义","date":"2017-04-01T07:01:18.000Z","path":"2017/04/01/first/","text":"开始用自己搭建的博客写文章，开森。。。 之所以写这篇博客，并不是我所介绍的内容很新颖独特，而是当我在网上搜寻解决这些问题的办法时，很少搜到给我明确方向的答案，所以，在搜寻答案失败之后，我还是打算自己来解决，一方面，如果有人遇到和我一样的问题而没有搜到答案，还有一方面，给我自己做一个笔记。不喜勿喷哦。。。 在我的项目中，采用了jqGrid这个表格插件，官方demos中的样式表采用的是jquery-ui的样式表来美化这个表格,由于用久了bootstrap，比较喜欢它简洁大方的气质，所以我选择用bootstrap来美化，但是效果不尽人意（样式冲突），所以，需要在调试中找出这些样式，然后，重新定义这些样式来达到我们的效果。 效果 引入的文件： 样式表这个例子中和原来的风格完全不一样。这张图片的每一个不同颜色的框都是一个表格。当然外面被div套着。在我们没有写自定义的样式表时，我们打开谷歌的调试，看样式，根据他的样式class来写自己自定义的样式表。比如：他的样式为.ui_state_hover{ color:#f8f8f8; },我们可以改成.ui_state_hover{color:#999;}这个样式表一定要放在ui.grid.css，bootstrap.css的后面来进行覆盖，如果覆盖不了，我们就进行权重比较。 图标说完了样式表，接下来说说图标。Jqgrid本身是不带图标的，一般是用别的例如jquery-ui来进行图标的替换。Bootstrap中也有图标。这里图标就成了一个问题了。就算是我们看到网页加载完后有图标的class，但是都没有图形，我们需要在表格动态加载完成之后，将图标的class换成bootstrap的图形icon，所以在gridComplete事件中来干这件事情。当然这里的图标的id也是不同的版本jqgrid有可能有所不同，所以还得再谷歌的调试工具中来看。 ###PS关于版本（主要是jqGrid.js，ui.grid.css）： 如果jqGrid.js和ui.grid.css的版本有所变化，那么那个tablestyle.css文件和index.js文件就得重新写，需要重新写的地方就是最后两张图所展示的部分。所以一般确定好这两个文件的版本，不可轻易变换。 后记我的代码可能不是适合你，主要在于思路和方法，自己动手，丰衣足食。","tags":[{"name":"jsGrid bootstrap table","slug":"jsGrid-bootstrap-table","permalink":"http://yoursite.com/tags/jsGrid-bootstrap-table/"}]},{"title":"Hello World","date":"2017-04-01T05:55:13.879Z","path":"2017/04/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]